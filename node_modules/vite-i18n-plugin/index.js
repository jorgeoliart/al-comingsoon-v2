const fs = require('fs');
const chalk = require('chalk');
const chokidar = require('chokidar');
const { fixString, makeFile, getPatten } = require('./utils');

let i18nData = {};
let options = {};
let useKeyList = {};
let watcher = null;
let isFirst = true;

const readFile = (sourcePath) => {
  try {
    const readJson = fs.readFileSync(sourcePath, { encoding: 'UTF-8' });
    return readJson ? JSON.parse(readJson) : {};
  } catch (err) {
    console.log(err);
  }
  return {};
};

const writeFile = () => {
  return new Promise((resolve, reject) => {
    const { formatSpace, sourcePath, languageList, removeUnUseKeys } = options;
    if (removeUnUseKeys === true) {
      options.removeUnUseKeys = false;
      Object.keys(i18nData).map((key) => {
        if (useKeyList.has(key) === false) {
          delete i18nData[key];
        }
      });
    }

    let newJson = {};
    let noTransfer = [];

    const untranslated = {};
    languageList.map((lang) => {
      untranslated[lang] = {
        count: 0,
        list: []
      };
    });
    Object.keys(i18nData)
      .sort()
      .map((key) => {
        const isTransfer = languageList.every((lang) => {
          if (!i18nData[key][lang]) {
            untranslated[lang].count++;
            untranslated[lang].list.push(key);
            return false;
          }
          return true;
        });
        if (isTransfer) {
          newJson[key] = i18nData[key];
        } else {
          noTransfer.push(key);
        }
      });
    noTransfer.map((key) => {
      newJson[key] = i18nData[key];
    });
    i18nData = newJson;

    if (options.autoWriteAble === false) {
      return resolve();
    }

    if (Object.keys(i18nData).length === 0) {
      return resolve();
    }

    fs.writeFile(sourcePath, JSON.stringify(i18nData, null, formatSpace), (err) => {
      if (err) return reject(err);
      Object.keys(untranslated).map((lang) => {
        const { count } = untranslated[lang];
        if (count > 0 && isFirst) {
          isFirst = false;
          console.log(chalk.rgb(97, 175, 239).underline(`'${lang}' untranslated amount: ${count}`));
        }
      });
      resolve();
    });
  });
};

const watchJsonFile = () => {
  watcher = chokidar.watch(options.sourcePath, { awaitWriteFinish: { pollInterval: 800 } });
  watcher.on('change', () => {
    const i18nJson = readFile(options.sourcePath);
    
    const { languageList } = options;
    Object.entries(i18nJson).map(([key, value]) => {
      languageList.map(lan => {
        if (value && value[lan]) {
          i18nData[key][lan] = value[lan];
        }
      });
    });
  });
};

const collectKeys = (key) => {
  const { languageList, useLanguage } = options;
  if (key in i18nData === false) {
    i18nData[key] = languageList.reduce((initObj, type) => {
      initObj[type] = useLanguage === type ? key : '';
      return initObj;
    }, {});
    return;
  }
  if (useLanguage && !i18nData[key][useLanguage]) {
    i18nData[key][useLanguage] = key;
  }
};

const replaceLiteral = (source) => {
  let result = null;
  let originSource = source;
  const { patten, langType } = options;
  while ((result = patten.exec(originSource))) {
    patten.lastIndex = 0;
    let [inputStr, key] = result;
    key = fixString(key);
    collectKeys(key);
    const langObj = i18nData[key];
    const lan = langType;
    originSource = originSource.replace(inputStr, langObj[lan] || key || '');
    useKeyList.add(key);
  }
  return originSource;
};

const init = (opts) => {
  options = Object.assign(
    {
      languageList: ['cn', 'en'],
      langType: 'cn',
      useLanguage: 'cn',
      autoWriteAble: true,
      formatSpace: 2,
      sourcePath: '',
      removeUnUseKeys: false,
      patten: getPatten(['__'])
    },
    opts || {}
  );
  makeFile(options.sourcePath);
  setTimeout(() => {
    console.log(chalk.rgb(152, 195, 121).underline(`\nI18n Json file path: ${chalk.underline.yellow(options.sourcePath)}`));
  }, 1e3);
  useKeyList = new Set();
  i18nData = readFile(options.sourcePath);
};

const serverI18nPlugin = (opts) => {
  init(opts);
  return ({ app }) => {
    let timer = 0;
    app.use(async (ctx, next) => {
      await next();
      if (typeof ctx.body === 'string') {
        ctx.body = replaceLiteral(ctx.body);
        clearTimeout(timer);
        timer = setTimeout(writeFile, 200);
      }
      return;
    });
  };
};

const buildI18nPlugin = (opts) => {
  init(opts);
  return {
    name: 'vite-i18n',
    transform (source) {
      return replaceLiteral(source);
    },
    buildEnd: writeFile
  };
};

let timer = 0;
let isViteServer = false;
function vitePluginI18n(opts) {
  init(opts);
  return {
    name: 'vite-i18n',
    configureServer() {
      watchJsonFile();
      isViteServer = true;
    },
    transform (source) {
      if (isViteServer) {
        clearTimeout(timer);
        timer = setTimeout(writeFile, 2000);
      }
      return replaceLiteral(source);
    },
    buildEnd: writeFile
  }
}

exports.vitePluginI18n = vitePluginI18n;
vitePluginI18n['default'] = vitePluginI18n;

exports.serverI18nPlugin = serverI18nPlugin;
exports.buildI18nPlugin = buildI18nPlugin;
